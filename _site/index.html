<!DOCTYPE html>
<html>
	<head>
		<script src="//treetopflyer.github.com/vcore/lib.js"></script>
	</head>
	<body>

		<script>
			
			var RBM = {};
			RBM.Bool = function(inMatrix)
			{
				var i, j;
				var rand;
				var outM = [];
				for(i=0; i<inMatrix.length; i++)
				{
					var outV = []
					for(j=0; j<inMatrix[i].length; j++)
					{
						rand = Math.random();
						if(rand < inMatrix[i][j])
						{
							outV[j] = 1;
						}
						else
						{
							outV[j] = 0;
						}
					}
					outM.push(outV);
				}
				return outM;
			};
			RBM.Create = function(inDimensionsIn, inDimensionsOut)
			{
				var obj = {};
				var min = [];
				var max = [];
				var i;
				for(i=0; i<inDimensionsIn; i++)
				{
					min.push(-0.5);
					max.push(0.5);
				}
				
				obj.MatrixForward = M.Box([min, max], inDimensionsOut);
				obj.MatrixBackward = M.Transpose(obj.MatrixForward);
				
				return obj;
			};
            RBM.Out = function(inRBM, inData)
            {
                affine = M.Transform(inRBM.MatrixForward, inData);
                sig = M.Sigmoid(affine);
                bool = RBM.Bool(sig);
                return bool;
            };
            RBM.Back = function(inRBM, inData)
            {
                affine = M.Transform(inRBM.MatrixBackward, inData);
                sig = M.Sigmoid(affine);
                bool = RBM.Bool(sig);
                return bool;
            };
            RBM.Adjust = function(inRBM, inPos, inNeg, inRate)
            {
                inRBM.MatrixForward = M.Add(inRBM.MatrixForward, M.Scale(inPos, inRate));
                inRBM.MatrixForward = M.Subtract(inRBM.MatrixForward, M.Scale(inNeg, inRate));
                inRBM.MatrixBackward = M.Transpose(inRBM.MatrixForward);  
            };
			RBM.Train = function(inRBM, inData, inRate)
			{
                var pass1 = inData;
                
                pass2 = RBM.Out(inRBM, pass1);
                pass3 = RBM.Back(inRBM, pass2);
                pass4 = RBM.Out(inRBM, pass3);
                
                var pos = M.Outer(inData[0], pass2[0]);
                var neg = M.Outer(inData[0], pass4[0])
                
                RBM.Adjust(inRBM, pos, neg, inRate);
			};
            RBM.Observe = function(inRBM, inData)
			{
                /*
                var pass1 = inData;
                pass2 = RBM.Out(inRBM, pass1);
                return RBM.Back(inRBM, pass2);
                */
                
                affine = M.Transform(inRBM.MatrixForward, inData);
                sig = M.Sigmoid(affine);
                
                affine = M.Transform(inRBM.MatrixBackward, sig);
                sig = M.Sigmoid(affine);
                
                return sig;
			};
			

            var trainingSet = [[0, 0, 1, 1]];
			var rbm1 = RBM.Create(4, 400);
			
            var i;
            for(i=0; i<10000; i++)
            {
               RBM.Train(rbm1, trainingSet, 0.5); 
            }
			
			console.log( RBM.Observe(rbm1, trainingSet) );
			
		</script>
	</body>
</html>